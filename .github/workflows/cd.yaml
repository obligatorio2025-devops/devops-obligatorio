name: CD - Deploy to AWS ECS

on:
  pull_request:
   #  types:
  # test    - closed
     branches:
       - develop
       - testing
       - main
  workflow_dispatch:
 
env:
  AWS_REGION: us-east-1

jobs:
  terraform:
    if: github.event.pull_request.merged == true
    name: Apply Terraform
    runs-on: ubuntu-latest
    outputs:
      ecs_cluster_name: ${{ steps.tfout.outputs.ecs_cluster_name }}
      ecs_service_name: ${{ steps.tfout.outputs.ecs_service_name }}
      api: ${{ steps.tfout.outputs.api }}
      inventory: ${{ steps.tfout.outputs.inventory }}
      product: ${{ steps.tfout.outputs.product }}
      alb_dns_name: ${{ steps.tfout.outputs.alb_dns_name }}

    steps:
      - name: Checkout repo            
        uses: actions/checkout@v4

      # Configurar credenciales AWS
      - name: Configuración de credenciales AWS
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      # Setup Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      # Determinar ambiente segun rama
      - name: Determinar ambiente según rama
        id: env
        run: |
          if [[ -n "$GITHUB_BASE_REF" ]]; then
            # Esto es un PR
            BRANCH="$GITHUB_BASE_REF"
          else
            # Esto es un push directo
            BRANCH="${GITHUB_REF##*/}"
          fi

          echo "Rama destino: $BRANCH"

          case "$BRANCH" in
            develop)
              echo "dir=terraform/envs/develop" >> $GITHUB_OUTPUT
              ;;
            testing)
              echo "dir=terraform/envs/testing" >> $GITHUB_OUTPUT
              ;;
            main)
              echo "dir=terraform/envs/production" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Rama '$BRANCH' no tiene ambiente configurado. Abortando workflow."
              exit 1
              ;;
          esac

      # Terraform Init / Plan / Apply
      - name: Terraform Init
        working-directory: ${{ steps.env.outputs.dir }}
        run: terraform init

      - name: Terraform Plan
        working-directory: ${{ steps.env.outputs.dir }}
        run: terraform plan

      - name: Terraform Apply
        working-directory: ${{ steps.env.outputs.dir }}
        run: terraform apply -auto-approve

      # Obtener outputs de Terraform
      - name: Obtener Terraform outputs
        id: tfout
        working-directory: ${{ steps.env.outputs.dir }}
        run: |
          terraform output -json > tf_outputs.json
          echo "ecs_cluster_name=$(jq -r '.ecs_cluster_name.value' < tf_outputs.json)" >> $GITHUB_OUTPUT
          echo "ecs_service_name=$(jq -r '.ecs_service_name.value' < tf_outputs.json)" >> $GITHUB_OUTPUT
          echo "api=$(jq -r '.api_gateway_ecr_url.value' < tf_outputs.json)" >> $GITHUB_OUTPUT
          echo "inventory=$(jq -r '.inventory_service_ecr_url.value' < tf_outputs.json)" >> $GITHUB_OUTPUT
          echo "product=$(jq -r '.product_service_ecr_url.value' < tf_outputs.json)" >> $GITHUB_OUTPUT
          echo "alb_dns_name=$(jq -r '.alb_dns_name.value' < tf_outputs.json)" >> $GITHUB_OUTPUT
      
      - name: Mostrar ALB URL
        working-directory: ${{ steps.env.outputs.dir }}
        run: |
          echo "ALB URL: http://${{ steps.tfout.outputs.alb_dns_name }}"

  build:
   # if: github.event.pull_request.merged == true
    name: Build & Push Microservice
    needs: terraform
    runs-on: ubuntu-latest
    steps: 
      - name: Checkout repo
        uses: actions/checkout@v4

      # Configurar credenciales AWS
      - name: Configuración de credenciales AWS
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      # Login a ECR
      - name: Login en Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # Build microservices
      - name: Build API Gateway
        working-directory: ./app/api-gateway
        run: |
          echo "Building API Gateway..."
          docker build -t stockwiz-api-gateway:latest .

      - name: Build Inventory Service
        working-directory: ./app/inventory-service
        run: |
          echo "Building Inventory Service..."
          docker build -t stockwiz-inventory-service:latest .

      - name: Build Product Service
        working-directory: ./app/product-service
        run: |
          echo "Building Product Service..."
          docker build -t stockwiz-product-service:latest .

      # Backup main.py solo en producción
      - name: Backup main.py antes del deploy (solo producción)
       # if: github.ref == 'refs/heads/main'
        env:
          BUCKET: backups-prod
        run: |
          echo "Haciendo backup de main.py en S3..."
          aws s3 cp ./app/product-service/main.py s3://$BUCKET/main-$(date +%Y%m%d-%H%M%S).py

      - name: Push microservicios a ECR
        env:
          API_ECR: ${{ needs.terraform.outputs.api }}
          INVENTORY_ECR: ${{ needs.terraform.outputs.inventory }}
          PRODUCT_ECR: ${{ needs.terraform.outputs.product }}
          IMAGE_TAG: ${{ github.sha }}

        run: |
          echo "Subiendo imágenes a ECR..."

          docker tag stockwiz-api-gateway:latest $API_ECR:latest
          docker push $API_ECR:latest

          docker tag stockwiz-inventory-service:latest $INVENTORY_ECR:latest
          docker push $INVENTORY_ECR:latest

          docker tag stockwiz-product-service:latest $PRODUCT_ECR:latest
          docker push $PRODUCT_ECR:latest

          echo "Imágenes subidas exitosamente"

  deploy:
    #if: github.event.pull_request.merged == true
    name: Deploy to ECS
    needs: [build, terraform]
    runs-on: ubuntu-latest  
    steps:
      - name: Config Github Checkout
        uses: actions/checkout@v4

      - name: Configurar AWS
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}
      
      # Actualizar servicio ECS usando outputs de Terraform
      - name: Update ECS Service
        env:
          CLUSTER_NAME: ${{ needs.terraform.outputs.ecs_cluster_name }}
          SERVICE_NAME: ${{ needs.terraform.outputs.ecs_service_name }}
        run: |
          echo "Actualizando servicios ECS..."

          aws ecs update-service --cluster $CLUSTER_NAME --service $API_SERVICE --force-new-deployment
          aws ecs update-service --cluster $CLUSTER_NAME --service $INVENTORY_SERVICE --force-new-deployment
          aws ecs update-service --cluster $CLUSTER_NAME --service $PRODUCT_SERVICE --force-new-deployment

          echo "Deployment en los 3 microservicios finalizado"